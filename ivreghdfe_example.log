-----------------------------------------------------------------------------------------------------------------------------------------
      name:  <unnamed>
       log:  /Users/mengdishi/Desktop/ivreghdfe_example.log
  log type:  text
 opened on:  18 Sep 2023, 15:02:15

. set trace on

. set tracedepth 2

. sysuse auto, clear
  ---------------------------------------------------------------------------------------------------------------------- begin sysuse ---
  - version 8
  - gettoken first : 0, parse(" ,") quotes
  - if `"`first'"'=="dir" {
  = if `"auto"'=="dir" {
    gettoken first 0 : 0, parse(" ,")
    sysusedir `0'
    exit
    }
  - local 0 `"using `0'"'
  = local 0 `"using auto, clear"'
  - syntax using/ [, CLEAR REPLACE]
  - local clear = cond("`replace'"!="", "clear", "`clear'")
  = local clear = cond(""!="", "clear", "clear")
  - if bsubstr(`"`using'"',-4,.)!=".dta" {
  = if bsubstr(`"auto"',-4,.)!=".dta" {
  - local using `"`using'.dta"'
  = local using `"auto.dta"'
  - }
  - quietly findfile `"`using'"'
  = quietly findfile `"auto.dta"'
    ------------------------------------------------------------------------------------------------------------------ begin findfile ---
    - version 8
    - gettoken fn 0 : 0, parse(" ,")
    - syntax [, ALL noDEScend PATH(string)]
    - if `"`path'"'=="" {
    = if `""'=="" {
    - local path `"`c(adopath)'"'
    = local path `"BASE;SITE;.;PERSONAL;PLUS;OLDPLACE"'
    - }
    - local n 0
    - local subdir : adosubdir `"`fn'"'
    = local subdir : adosubdir `"auto.dta"'
    - if `"`subdir'"' != "" {
    = if `"a"' != "" {
    - gettoken d path : path, parse(";")
    - while `"`d'"'!="" {
    = while `"BASE"'!="" {
    - if `"`d'"' != ";" {
    = if `"BASE"' != ";" {
    - local d : sysdir `"`d'"'
    = local d : sysdir `"BASE"'
    - local ffn `"`d'`fn'"'
    = local ffn `"/Applications/Stata/ado/base/auto.dta"'
    - capture confirm file `"`ffn'"'
    = capture confirm file `"/Applications/Stata/ado/base/auto.dta"'
    - if _rc==0 {
      di as txt `"`ffn'"'
      if "`all'"=="" {
      ret local fn `"`ffn'"'
      exit
      }
      if `n' {
      ret local fn `"`return(fn)' "`ffn'""'
      }
      else ret local fn `""`ffn'""'
      local n 1
      }
    - if "`descend'"=="" {
    = if ""=="" {
    - local ffn `"`d'`subdir'`c(dirsep)'`fn'"'
    = local ffn `"/Applications/Stata/ado/base/a/auto.dta"'
    - capture confirm file `"`ffn'"'
    = capture confirm file `"/Applications/Stata/ado/base/a/auto.dta"'
    - if _rc==0 {
    - di as txt `"`ffn'"'
    = di as txt `"/Applications/Stata/ado/base/a/auto.dta"'
    - if "`all'"=="" {
    = if ""=="" {
    - ret local fn `"`ffn'"'
    = ret local fn `"/Applications/Stata/ado/base/a/auto.dta"'
    - exit
    -------------------------------------------------------------------------------------------------------------------- end findfile ---
  - capture noisily use `"`r(fn)'"', `clear'
  = capture noisily use `"/Applications/Stata/ado/base/a/auto.dta"', clear
(1978 automobile data)
  - if _rc==0 {
  - capture window menu add_recentfiles `"`r(fn)'"', rlevel(1)
  = capture window menu add_recentfiles `"/Applications/Stata/ado/base/a/auto.dta"', rlevel(1)
  - }
  - else {
    exit _rc
    }
  ------------------------------------------------------------------------------------------------------------------------ end sysuse ---

. 
. reghdfe headroom mpg weight, absorb(rep78)
  --------------------------------------------------------------------------------------------------------------------- begin reghdfe ---
  - cap syntax, store_alphas
  - if (!c(rc)) {
    Store_Alphas
    exit
    }
  - cap syntax, shrug
  - if (!c(rc)) {
    di as text _n `"    {browse "https://www.theawl.com/2014/05/the-life-and-times-of-%C2%AF_%E3%83%84_%C2%AF/":¯\_(ツ)_/¯}"'
    exit
    }
  - cap syntax, worker [*]
  - if (!c(rc)) {
    ParallelWorker, `options'
    exit
    }
  - cap syntax anything(everything) [fw aw pw/], [*] VERSION(integer) [noWARN]
  - if !c(rc) {
    _assert inlist(`version', 3, 5)
    if ("`warn'" != "nowarn") di as error "(running historical version of reghdfe: `version')"
    if ("`weight'"!="") local weightexp [`weight'=`exp']
    if (`version' == 3) {
    reghdfe3 `anything' `weightexp', `options'
    }
    else {
    reghdfe5 `anything' `weightexp', `options'
    }
    exit
    }
  - if replay() {
    Replay `0'
    exit
    }
  - loc keep_mata 0
  - Cleanup 0 `keep_mata'
  = Cleanup 0 0
    ----------------------------------------------------------------------------------------------------------- begin reghdfe.Cleanup ---
    - args rc keep_mata
    - loc cleanup_folder = !`keep_mata' & ("$LAST_PARALLEL_DIR"!="")
    = loc cleanup_folder = !0 & (""!="")
    - if (`cleanup_folder') cap mata: unlink_folder(HDFE.parallel_dir, 0)
    = if (0) cap mata: unlink_folder(HDFE.parallel_dir, 0)
    - global LAST_PARALLEL_DIR
    - global pids
    - if (!`keep_mata') cap mata: mata drop HDFE
    = if (!0) cap mata: mata drop HDFE
    - cap mata: mata drop hdfe_*
    - cap drop __temp_reghdfe_resid__
    - if (`rc') exit `rc'
    = if (0) exit 0
    ------------------------------------------------------------------------------------------------------------- end reghdfe.Cleanup ---
  - qui which ftools
  - ms_get_version ftools, min_version("2.49.1")
    ------------------------------------------------------------------------------------------------------------ begin ms_get_version ---
    - syntax anything(name=ado), [min_version(string) min_date(string)]
    - mata: st_local("package_version", get_version("`ado'"))
    = mata: st_local("package_version", get_version("ftools"))
    - c_local package_version "`package_version'"
    = c_local package_version "2.49.1 08aug2023"
    - loc _ `package_version'
    = loc _ 2.49.1 08aug2023
    - gettoken version_number _ : _
    - gettoken version_date _ : _
    - c_local version_number "`version_number'"
    = c_local version_number "2.49.1"
    - c_local version_date "`version_date'"
    = c_local version_date "08aug2023"
    - if ("`min_version'" != "") {
    = if ("2.49.1" != "") {
    - loc ok 0
    - cap mata: st_local("ok", strofreal(strtoreal(tokens(subinstr("`version_number'", ".", " "))) * (1e5, 1e3, 1)' >= strtoreal(tokens(s
> ubinstr("`min_version'", ".", " "))) * (1e5, 1e3, 1)'))
    = cap mata: st_local("ok", strofreal(strtoreal(tokens(subinstr("2.49.1", ".", " "))) * (1e5, 1e3, 1)' >= strtoreal(tokens(subinstr("2
> .49.1", ".", " "))) * (1e5, 1e3, 1)'))
    - _assert `ok', msg("you are using version `version_number' of `ado', but require version `min_version'")
    = _assert 1, msg("you are using version 2.49.1 of ftools, but require version 2.49.1")
    - }
    - if ("`min_date'" != "") {
    = if ("" != "") {
      loc ok = !mi(date("`version_date'", "DMY")) & (date("`version_date'", "DMY") >= date("`min_date'", "DMY"))
      _assert `ok', msg("you are using `ado' from `version_date', but require a version from at `min_date' or later")
      }
    -------------------------------------------------------------------------------------------------------------- end ms_get_version ---
  - cap noi Estimate `0'
  = cap noi Estimate headroom mpg weight, absorb(rep78)
    ---------------------------------------------------------------------------------------------------------- begin reghdfe.Estimate ---
    - syntax varlist(fv ts numeric) [if] [in] [fw aw pw/] [ , Absorb(string) Group_id(varname numeric) Individual_id(varname numeric) AGg
> regation(string) VCE(string) CLuster(string) RESiduals(name) RESiduals2 DOFadjustments(string) GROUPVar(name) TEChnique(string) TOLeran
> ce(real 1e-8) ITERATE(real 16000) TRAnsform(string) ACCELeration(string) PREConditioner(string) PRUNE NOSAMPle COMPACT POOLsize(integer
>  10) PARallel(string asis) noHEader noTABle noFOOTnote Verbose(integer 0) noWARN TIMEit KEEPSINgletons noPARTIALout varlist_is_touse no
> REGress KEEPMATA FASTREGress noCONstant noAbsorb2 ] [*]
    - loc timeit = ("`timeit'"!="")
    = loc timeit = (""!="")
    - if (`timeit') timer on 20
    = if (0) timer on 20
    - if (`verbose' >= 2) di _n `"{txt}{bf:[CMD]} {inp}reghdfe `0'"'
    = if (0 >= 2) di _n `"{txt}{bf:[CMD]} {inp}reghdfe headroom mpg weight, absorb(rep78)"'
    - cap drop __hdfe*
    - if (`verbose' > 0) di as text "{title:Parsing and validating options:}" _n
    = if (0 > 0) di as text "{title:Parsing and validating options:}" _n
    - _get_diopts diopts options, `options'
    = _get_diopts diopts options, 
    - loc drop_singletons = ("`keepsingletons'" == "")
    = loc drop_singletons = ("" == "")
    - loc compact = ("`compact'" != "")
    = loc compact = ("" != "")
    - loc has_standard_fe = (`"`absorb'"' != "")
    = loc has_standard_fe = (`"rep78"' != "")
    - loc report_constant = "`constant'" != "noconstant"
    = loc report_constant = "" != "noconstant"
    - loc has_teams = (`"`group_id'"' != "")
    = loc has_teams = (`""' != "")
    - loc has_individual_fe = (`"`individual_id'"' != "")
    = loc has_individual_fe = (`""' != "")
    - loc stop_before_partial_out = ("`partialout'" == "nopartialout")
    = loc stop_before_partial_out = ("" == "nopartialout")
    - loc stop_before_regression = ("`regress'" == "noregress")
    = loc stop_before_regression = ("" == "noregress")
    - loc fast_regression = ("`fastregress'" == "fastregress")
    = loc fast_regression = ("" == "fastregress")
    - if (`has_individual_fe') _assert `has_teams', msg("cannot set the individual() identifiers without the group() identifiers") rc(198
> )
    = if (0) _assert 0, msg("cannot set the individual() identifiers without the group() identifiers") rc(198)
    - if ("`technique'" == "") loc technique = cond("`individual_id'"=="", "map", "lsmr")
    = if ("" == "") loc technique = cond(""=="", "map", "lsmr")
    - if ("`transform'" == "") loc transform "symmetric_kaczmarz"
    = if ("" == "") loc transform "symmetric_kaczmarz"
    - if ("`acceleration'" == "") loc acceleration "conjugate_gradient"
    = if ("" == "") loc acceleration "conjugate_gradient"
    - if ("`preconditioner'" == "") loc preconditioner "block_diagonal"
    = if ("" == "") loc preconditioner "block_diagonal"
    - if (`poolsize' == 0) loc poolsize = .
    = if (10 == 0) loc poolsize = .
    - if (`verbose'>-1 & "`keepsingletons'"!="" & "`warn'" != "nowarn") {
    = if (0>-1 & ""!="" & "" != "nowarn") {
      loc url "http://scorreia.com/reghdfe/nested_within_cluster.pdf"
      loc msg "WARNING: Singleton observations not dropped; statistical significance is biased"
      di as error `"`msg' {browse "`url'":(link)}"'
      }
    - if ("`cluster'"!="") {
    = if (""!="") {
      _assert ("`vce'"==""), msg("only one of cluster() and vce() can be specified") rc(198)
      loc vce cluster `cluster'
      }
    - if ("`aggregation'" == "") loc aggregation mean
    = if ("" == "") loc aggregation mean
    - if ("`aggregation'" == "average" | "`aggregation'" == "avg") loc aggregation mean
    = if ("mean" == "average" | "mean" == "avg") loc aggregation mean
    - _assert inlist("`aggregation'", "mean", "sum")
    = _assert inlist("mean", "mean", "sum")
    - loc function_individual "`aggregation'"
    = loc function_individual "mean"
    - if (`verbose' > 0) di as text "# Parsing varlist: {res}`varlist'" _c
    = if (0 > 0) di as text "# Parsing varlist: {res}headroom mpg weight" _c
    - ms_parse_varlist `varlist'
    = ms_parse_varlist headroom mpg weight
    - if (`verbose' > 0) return list
    = if (0 > 0) return list
    - loc depvar `r(depvar)'
    = loc depvar headroom
    - loc indepvars `r(indepvars)'
    = loc indepvars mpg weight
    - loc fe_format "`r(fe_format)'"
    = loc fe_format "%6.1f"
    - loc basevars `r(basevars)'
    = loc basevars headroom mpg weight
    - if ("`weight'"!="") unab exp : `exp', min(1) max(1)
    = if (""!="") unab exp : , min(1) max(1)
    - if (`verbose' > 0) di as text _n "# Parsing vce({res}`vce'{txt})" _c
    = if (0 > 0) di as text _n "# Parsing vce({res}{txt})" _c
    - ms_parse_vce, vce(`vce') weighttype(`weight')
    = ms_parse_vce, vce() weighttype()
    - if (`verbose' > 0) sreturn list
    = if (0 > 0) sreturn list
    - loc vcetype `s(vcetype)'
    = loc vcetype unadjusted
    - loc clustervars `s(clustervars)'
    = loc clustervars 
    - loc base_clustervars `s(base_clustervars)'
    = loc base_clustervars 
    - loc num_clusters = `s(num_clusters)'
    = loc num_clusters = 0
    - confirm variable `base_clustervars', exact
    = confirm variable , exact
    - if (`stop_before_partial_out' & "`varlist_is_touse'" != "") {
    = if (0 & "" != "") {
      loc touse `varlist'
      loc varlist
      markout `touse' `base_clustervars' `group_id' `individual_id', strok
      }
    - else {
    - loc varlist `depvar' `indepvars' `base_clustervars' `group_id' `individual_id'
    = loc varlist headroom mpg weight   
    - marksample touse, strok
    - la var `touse' "[touse]"
    = la var __000000 "[touse]"
    - }
    - if (`stop_before_partial_out') loc varlist
    = if (0) loc varlist
    - loc valid_techniques map cg lsmr lsqr
    - _assert (`: list technique in valid_techniques'), msg("invalid technique: `technique'")
    = _assert (1), msg("invalid technique: map")
    - loc transform = lower("`transform'")
    = loc transform = lower("symmetric_kaczmarz")
    - loc valid_transforms cimmino kaczmarz symmetric_kaczmarz rand_kaczmarz
    - foreach x of local valid_transforms {
    - if (strpos("`x'", "`transform'")==1) loc transform `x'
    = if (strpos("cimmino", "symmetric_kaczmarz")==1) loc transform cimmino
    - }
    - if (strpos("`x'", "`transform'")==1) loc transform `x'
    = if (strpos("kaczmarz", "symmetric_kaczmarz")==1) loc transform kaczmarz
    - }
    - if (strpos("`x'", "`transform'")==1) loc transform `x'
    = if (strpos("symmetric_kaczmarz", "symmetric_kaczmarz")==1) loc transform symmetric_kaczmarz
    - }
    - if (strpos("`x'", "`transform'")==1) loc transform `x'
    = if (strpos("rand_kaczmarz", "symmetric_kaczmarz")==1) loc transform rand_kaczmarz
    - }
    - _assert (`: list transform in valid_transforms'), msg("invalid transform: `transform'")
    = _assert (1), msg("invalid transform: symmetric_kaczmarz")
    - loc acceleration = lower("`acceleration'")
    = loc acceleration = lower("conjugate_gradient")
    - if ("`acceleration'"=="cg") loc acceleration conjugate_gradient
    = if ("conjugate_gradient"=="cg") loc acceleration conjugate_gradient
    - if ("`acceleration'"=="sd") loc acceleration steepest_descent
    = if ("conjugate_gradient"=="sd") loc acceleration steepest_descent
    - if ("`acceleration'"=="off") loc acceleration none
    = if ("conjugate_gradient"=="off") loc acceleration none
    - loc valid_accelerations conjugate_gradient steepest_descent aitken none
    - foreach x of local valid_accelerations {
    - if (strpos("`x'", "`acceleration'")==1) loc acceleration `x'
    = if (strpos("conjugate_gradient", "conjugate_gradient")==1) loc acceleration conjugate_gradient
    - }
    - if (strpos("`x'", "`acceleration'")==1) loc acceleration `x'
    = if (strpos("steepest_descent", "conjugate_gradient")==1) loc acceleration steepest_descent
    - }
    - if (strpos("`x'", "`acceleration'")==1) loc acceleration `x'
    = if (strpos("aitken", "conjugate_gradient")==1) loc acceleration aitken
    - }
    - if (strpos("`x'", "`acceleration'")==1) loc acceleration `x'
    = if (strpos("none", "conjugate_gradient")==1) loc acceleration none
    - }
    - _assert (`: list acceleration in valid_accelerations'), msg("invalid acceleration: `acceleration'")
    = _assert (1), msg("invalid acceleration: conjugate_gradient")
    - loc preconditioner = lower("`preconditioner'")
    = loc preconditioner = lower("block_diagonal")
    - if ("`preconditioner'"=="off") loc preconditioner none
    = if ("block_diagonal"=="off") loc preconditioner none
    - loc valid_preconditioners none diagonal block_diagonal
    - foreach x of local valid_preconditioners {
    - if (strpos("`x'", "`preconditioner'")==1) loc preconditioner `x'
    = if (strpos("none", "block_diagonal")==1) loc preconditioner none
    - }
    - if (strpos("`x'", "`preconditioner'")==1) loc preconditioner `x'
    = if (strpos("diagonal", "block_diagonal")==1) loc preconditioner diagonal
    - }
    - if (strpos("`x'", "`preconditioner'")==1) loc preconditioner `x'
    = if (strpos("block_diagonal", "block_diagonal")==1) loc preconditioner block_diagonal
    - }
    - _assert (`: list preconditioner in valid_preconditioners'), msg("invalid preconditioner: `preconditioner'")
    = _assert (1), msg("invalid preconditioner: block_diagonal")
    - if (`verbose' > 0) di as text _n `"# Parsing dof({res}`dofadjustments'{txt})"' _c
    = if (0 > 0) di as text _n `"# Parsing dof({res}{txt})"' _c
    - ParseDOF, `dofadjustments'
    = ParseDOF, 
    - loc dofadjustments `s(dofadjustments)'
    = loc dofadjustments pairwise clusters continuous
    - if (`verbose' > 0) sreturn list
    = if (0 > 0) sreturn list
    - opts_exclusive "`residuals' `residuals2'" residuals
    = opts_exclusive " " residuals
    - if ("`residuals2'" != "") {
    = if ("" != "") {
      cap drop _reghdfe_resid
      loc residuals _reghdfe_resid
      }
    - else if ("`residuals'"!="") {
    = else if (""!="") {
      conf new var `residuals'
      }
    - if (`"`parallel'"' != "") {
    = if (`""' != "") {
      if (`verbose' > 0) di as text _n `"# Parsing parallel options: {inp}`parallel'"' _c
      ParseParallel `parallel'
      if (`verbose' > 0) sreturn list
      loc parallel_maxproc `s(parallel_maxproc)'
      loc parallel_dir `"`s(parallel_dir)'"'
      loc parallel_force `s(parallel_force)'
      loc parallel_opts `"`s(parallel_opts)'"'
      }
    - else {
    - loc parallel_maxproc 0
    - loc parallel_force 0
    - }
    - if (`has_teams') {
    = if (0) {
      tempvar indiv_tousevar
      ValidateGroups `basevars' `base_clustervars' `exp', group_id(`group_id') touse(`touse') indivtouse(`indiv_tousevar') individual(`in
> dividual_id')
      _assert ("`weight_type'"=="fweight") + ("`indiv_tousevar'" != "") < 2, msg("fweights are incompatible with individual ids as there 
> cannot be two observations for a given group-individual touple")
      }
    - mata: HDFE = FixedEffects()
    - if (`verbose' > 0) di as text _n `"# Passing main options to Mata"' _n
    = if (0 > 0) di as text _n `"# Passing main options to Mata"' _n
    - loc absvars `"`absorb'"'
    = loc absvars `"rep78"'
    - loc tousevar `"`touse'"'
    = loc tousevar `"__000000"'
    - loc weight_type `"`weight'"'
    = loc weight_type `""'
    - loc weight_var `"`exp'"'
    = loc weight_var `""'
    - loc optim_options absvars tousevar weight_type weight_var technique transform acceleration preconditioner parallel_dir parallel_opt
> s
    - if (`has_teams') loc optim_options `optim_options' group_id individual_id indiv_tousevar function_individual
    = if (0) loc optim_options absvars tousevar weight_type weight_var technique transform acceleration preconditioner parallel_dir paral
> lel_opts group_id individual_id indiv_tousevar function_individual
    - foreach opt of local optim_options {
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.absvars = {res}`"rep78"' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.absvars = `"rep78"'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.tousevar = {res}`"__000000"' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.tousevar = `"__000000"'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.weight_type = {res}`""' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.weight_type = `""'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.weight_var = {res}`""' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.weight_var = `""'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.technique = {res}`"map"' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.technique = `"map"'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.transform = {res}`"symmetric_kaczmarz"' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.transform = `"symmetric_kaczmarz"'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.acceleration = {res}`"conjugate_gradient"' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.acceleration = `"conjugate_gradient"'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.preconditioner = {res}`"block_diagonal"' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.preconditioner = `"block_diagonal"'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.parallel_dir = {res}`""' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.parallel_dir = `""'
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}`"``opt''"' "'
    = if (0 > 0) di as text `"    - HDFE.parallel_opts = {res}`""' "'
    - mata: HDFE.`opt' = `"``opt''"'
    = mata: HDFE.parallel_opts = `""'
    - }
    - loc maxiter = `iterate'
    = loc maxiter = 16000
    - loc optim_options drop_singletons tolerance maxiter compact poolsize verbose parallel_maxproc parallel_force timeit
    - foreach opt of local optim_options {
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.drop_singletons = {res}1"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.drop_singletons = 1
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.tolerance = {res}1.00000000000e-08"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.tolerance = 1.00000000000e-08
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.maxiter = {res}16000"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.maxiter = 16000
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.compact = {res}0"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.compact = 0
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.poolsize = {res}10"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.poolsize = 10
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.verbose = {res}0"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.verbose = 0
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.parallel_maxproc = {res}0"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.parallel_maxproc = 0
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.parallel_force = {res}0"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.parallel_force = 0
    - }
    - if (`verbose' > 0) di as text `"    - HDFE.`opt' = {res}``opt''"'
    = if (0 > 0) di as text `"    - HDFE.timeit = {res}0"'
    - mata: HDFE.`opt' = ``opt''
    = mata: HDFE.timeit = 0
    - }
    - if (`verbose' > 0) di as text _n `"# Parsing absorb({res}`absorb'{txt}) and initializing FixedEffects() object"'
    = if (0 > 0) di as text _n `"# Parsing absorb({res}rep78{txt}) and initializing FixedEffects() object"'
    - if (`timeit') timer on 21
    = if (0) timer on 21
    - mata: HDFE.init()
    - if (`timeit') timer off 21
    = if (0) timer off 21
    - mata: add_undocumented_options("HDFE", `"`options'"', `verbose')
    = mata: add_undocumented_options("HDFE", `""', 0)
    - if (`compact') {
    = if (0) {
      loc panelvar "`_dta[_TSpanel]'"
      loc timevar "`_dta[_TStvar]'"
      cap conf var `panelvar', exact
      if (c(rc)) loc panelvar
      mata: HDFE.panelvar = "`panelvar'"
      cap conf var `timevar', exact
      if (c(rc)) loc timevar
      mata: HDFE.timevar = "`timevar'"
      if (`verbose' > 0) di as text "## Preserving dataset"
      preserve
      novarabbrev keep `basevars' `base_clustervars' `panelvar' `timevar' `touse'
      }
    - mata: HDFE.vcetype = "`vcetype'"
    = mata: HDFE.vcetype = "unadjusted"
    - mata: HDFE.num_clusters = `num_clusters'
    = mata: HDFE.num_clusters = 0
    - mata: HDFE.clustervars = tokens("`clustervars'")
    = mata: HDFE.clustervars = tokens("")
    - mata: HDFE.base_clustervars = tokens("`base_clustervars'")
    = mata: HDFE.base_clustervars = tokens("")
    - if (`timeit') timer on 22
    = if (0) timer on 22
    - mata: estimate_dof(HDFE, tokens("`dofadjustments'"), "`groupvar'")
    = mata: estimate_dof(HDFE, tokens("pairwise clusters continuous"), "")
    - if (`timeit') timer off 22
    = if (0) timer off 22
    - if (`stop_before_partial_out') {
    = if (0) {
      if (`verbose' > 0) di as text "{title:Stopping reghdfe without partialling out}" _n
      c_local keep_mata 1
      exit
      }
    - if (`verbose' > 0) di as text "{title:Working on varlist: partialling out and regression}" _n
    = if (0 > 0) di as text "{title:Working on varlist: partialling out and regression}" _n
    - if (`verbose' > 0) di as text "# Parsing and expanding indepvars: {res}`indepvars'" _c
    = if (0 > 0) di as text "# Parsing and expanding indepvars: {res}mpg weight" _c
    - if (`timeit') timer on 23
    = if (0) timer on 23
    - ms_expand_varlist `indepvars' if `touse'
    = ms_expand_varlist mpg weight if __000000
    - if (`timeit') timer off 23
    = if (0) timer off 23
    - if (`verbose' > 0) return list
    = if (0 > 0) return list
    - loc indepvars "`r(varlist)'"
    = loc indepvars "mpg weight"
    - loc fullindepvars "`r(fullvarlist)'"
    = loc fullindepvars "mpg weight"
    - loc fullindepvars_bn "`r(fullvarlist_bn)'"
    = loc fullindepvars_bn "mpg weight"
    - loc not_omitted "`r(not_omitted)'"
    = loc not_omitted "1 1"
    - if (`timeit') timer on 24
    = if (0) timer on 24
    - mata: HDFE.partial_out("`depvar' `indepvars'", 1, 1)
    = mata: HDFE.partial_out("headroom mpg weight", 1, 1)
(MWFE estimator converged in 1 iterations)
    - if (`timeit') timer off 24
    = if (0) timer off 24
    - if (`parallel_maxproc' > 0) {
    = if (0 > 0) {
      if (`timeit') timer on 27
      ParallelBoss
      if (`timeit') timer off 27
      }
    - mata: HDFE.solution.depvar = "`depvar'"
    = mata: HDFE.solution.depvar = "headroom"
    - mata: HDFE.solution.indepvars = tokens("`indepvars'")
    = mata: HDFE.solution.indepvars = tokens("mpg weight")
    - mata: HDFE.solution.fullindepvars = tokens("`fullindepvars'")
    = mata: HDFE.solution.fullindepvars = tokens("mpg weight")
    - mata: HDFE.solution.fullindepvars_bn = tokens("`fullindepvars_bn'")
    = mata: HDFE.solution.fullindepvars_bn = tokens("mpg weight")
    - mata: HDFE.solution.indepvar_status = !strtoreal(tokens("1 `not_omitted'"))
    = mata: HDFE.solution.indepvar_status = !strtoreal(tokens("1 1 1"))
    - mata: HDFE.solution.collinear_tol = min(( 1e-6 , HDFE.tolerance / 10))
    - mata: HDFE.solution.check_collinear_with_fe(`verbose')
    = mata: HDFE.solution.check_collinear_with_fe(0)
    - mata: HDFE.solution.fast_regression = `fast_regression'
    = mata: HDFE.solution.fast_regression = 0
    - if (`stop_before_regression') {
    = if (0) {
      if (`verbose' > 0) di as text "{title:Stopping reghdfe without running regression}" _n
      c_local keep_mata 1
      exit
      }
    - mata: HDFE.solution.report_constant = HDFE.has_intercept & `report_constant'
    = mata: HDFE.solution.report_constant = HDFE.has_intercept & 1
    - if ("`keepmata'" != "") mata: hdfe_data = HDFE.solution.data
    = if ("" != "") mata: hdfe_data = HDFE.solution.data
    - if ("`keepmata'" != "") mata: hdfe_tss = HDFE.solution.tss
    = if ("" != "") mata: hdfe_tss = HDFE.solution.tss
    - if (`timeit') timer on 25
    = if (0) timer on 25
    - mata: reghdfe_solve_ols(HDFE, HDFE.solution, "vce_small")
    - if (`timeit') timer off 25
    = if (0) timer off 25
    - mata: HDFE.solution.cmdline = HDFE.solution.cmd + " " + st_local("0")
    - if (`compact') {
    = if (0) {
      if (`verbose' > 0) di as text "## Restoring dataset"
      restore
      }
    - if (`verbose' > 0) di as text "{title:Posting results to e() and displaying them}" _n
    = if (0 > 0) di as text "{title:Posting results to e() and displaying them}" _n
    - tempname b V
    - mata: HDFE.solution.expand_results("`b'", "`V'", HDFE.verbose)
    = mata: HDFE.solution.expand_results("__000001", "__000002", HDFE.verbose)
    - loc store_sample = ("`nosample'"=="")
    = loc store_sample = (""=="")
    - EreturnPost `touse' `b' `V' `store_sample'
    = EreturnPost __000000 __000001 __000002 1
    - mata: st_local("save_any_fe", strofreal(HDFE.save_any_fe))
    - if ("`residuals'" == "" & `save_any_fe') loc residuals "__temp_reghdfe_resid__"
    = if ("" == "" & 0) loc residuals "__temp_reghdfe_resid__"
    - if ("`residuals'" != "") {
    = if ("" != "") {
      if (`verbose' > 0) di as text "# Storing residuals in {res}`residuals'{txt}" _n
      mata: HDFE.save_variable("`residuals'", HDFE.solution.resid, "Residuals")
      mata: HDFE.solution.residuals_varname = "`residuals'"
      }
    - mata: HDFE.solution.post()
    - mata: HDFE.post_footnote()
    - if (`timeit') timer on 28
    = if (0) timer on 28
    - reghdfe, store_alphas
    - if (`timeit') timer off 28
    = if (0) timer off 28
    - Replay, `diopts' `header' `table' `footnote'
    = Replay,    

HDFE Linear regression                            Number of obs   =         69
Absorbing 1 HDFE group                            F(   2,     62) =       7.12
                                                  Prob > F        =     0.0016
                                                  R-squared       =     0.3078
                                                  Adj R-squared   =     0.2408
                                                  Within R-sq.    =     0.1867
                                                  Root MSE        =     0.7434

------------------------------------------------------------------------------
    headroom | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
         mpg |  -.0009176   .0268192    -0.03   0.973    -.0545285    .0526932
      weight |   .0004776   .0001953     2.45   0.017     .0000872    .0008681
       _cons |   1.571309   1.093504     1.44   0.156    -.6145753    3.757193
------------------------------------------------------------------------------

Absorbed degrees of freedom:
-----------------------------------------------------+
 Absorbed FE | Categories  - Redundant  = Num. Coefs |
-------------+---------------------------------------|
       rep78 |         5           0           5     |
-----------------------------------------------------+
    - if ("`keepmata'" != "") mata: swap(HDFE.solution.data, hdfe_data)
    = if ("" != "") mata: swap(HDFE.solution.data, hdfe_data)
    - if ("`keepmata'" != "") mata: swap(HDFE.solution.tss, hdfe_tss)
    = if ("" != "") mata: swap(HDFE.solution.tss, hdfe_tss)
    - if ("`keepmata'" != "") c_local keep_mata 1
    = if ("" != "") c_local keep_mata 1
    - if (`timeit') {
    = if (0) {
      timer off 20
      ViewTimer, title("Top-level") percent range(20 29) legend(21 "HDFE" 22 "DoF" 23 "Expand factors/Lags" 24 "Partial out" 25 "Solve OL
> S" 27 "Parallel Boss" 28 "Store alphas")
      ViewTimer, title("Partial-out") percent range(40 49) legend(41 "Load data" 42 "Standardize/etc" 46 "MAP/LSMR" 47 "Data assign" 49 "
> Parallel Save")
      }
    ------------------------------------------------------------------------------------------------------------ end reghdfe.Estimate ---
  - Cleanup `c(rc)' `keep_mata'
  = Cleanup 0 0
    ----------------------------------------------------------------------------------------------------------- begin reghdfe.Cleanup ---
    - args rc keep_mata
    - loc cleanup_folder = !`keep_mata' & ("$LAST_PARALLEL_DIR"!="")
    = loc cleanup_folder = !0 & (""!="")
    - if (`cleanup_folder') cap mata: unlink_folder(HDFE.parallel_dir, 0)
    = if (0) cap mata: unlink_folder(HDFE.parallel_dir, 0)
    - global LAST_PARALLEL_DIR
    - global pids
    - if (!`keep_mata') cap mata: mata drop HDFE
    = if (!0) cap mata: mata drop HDFE
    - cap mata: mata drop hdfe_*
    - cap drop __temp_reghdfe_resid__
    - if (`rc') exit `rc'
    = if (0) exit 0
    ------------------------------------------------------------------------------------------------------------- end reghdfe.Cleanup ---
  ----------------------------------------------------------------------------------------------------------------------- end reghdfe ---

. 
. ivreghdfe headroom mpg (weight = length), absorb(rep78)
  ------------------------------------------------------------------------------------------------------------------- begin ivreghdfe ---
  - local lversion 04.1.10
  - version 8
  - if replay() {
    syntax [, VERsion * ]
    if "`version'"~="" & "`options'"=="" {
    di in gr "`lversion'"
    ereturn clear
    ereturn local version `lversion'
    exit
    }
    else if "`version'"~="" & "`options'"~="" {
    di as err "invalid syntax - cannot combine version with other options"
    exit 198
    }
    else {
    local 0 `", `options'"'
    }
    }
  - if replay() & _by() {
    di as err "invalid syntax - cannot use by with replay"
    exit 601
    }
  - if _by() {
    local BY `"by `_byvars'`_byrc0':"'
    }
  - if _caller() < 11 {
    local ver = round(_caller())
    local ivreg2cmd ivreg2`ver'
    if replay() {
    ereturn local cmd "`ivreg2cmd'"
    `ivreg2cmd' `0'
    ereturn local cmd "ivreg2"
    }
    else {
    `BY' `ivreg2cmd' `0'
    ereturn local cmd "ivreghdfe"
    ereturn local ivreg2cmd "`ivreg2cmd'"
    ereturn local version `lversion'
    ereturn local predict ivreg2_p
    }
    exit
    }
  - if replay() {
    ivreg211 `0'
    }
  - else {
  - `BY' ivreg211 `0'
  =  ivreg211 headroom mpg (weight = length), absorb(rep78)
    -------------------------------------------------------------------------------------------------------- begin ivreghdfe.ivreg211 ---
    - version 11.2
    - local ranktestversion 01.3.02
    - local ivreg2cmd "ivreg211"
    - local ivreg2name "ivreg2"
    - local ranktestcmd "ranktest"
    - if replay() {
      syntax [, FIRST FFIRST RF SFIRST dropfirst droprf dropsfirst Level(integer $S_level) NOHEader NOFOoter EForm(string) PLUS NOOMITTED
>  vsquish noemptycells baselevels allbaselevels VERsion ]
      if "`version'" != "" & "`first'`ffirst'`rf'`noheader'`nofooter'`dropfirst'`droprf'`eform'`plus'" != "" {
      di as err "option version not allowed"
      error 198
      }
      if "`version'" != "" {
      di in gr "`lversion'"
      ereturn clear
      ereturn local version `lversion'
      exit
      }
      if `"`e(cmd)'"' != "ivreghdfe" {
      error 301
      }
      local dispopt eform(`eform') `noomitted' `vsquish' `noemptycells' `baselevels' `allbaselevels'
      if "`e(firsteqs)'" != "" & "`dropfirst'" == "" {
      local savefirst "savefirst"
      }
      if "`e(rfeq)'" != "" & "`droprf'" == "" {
      local saverf "saverf"
      }
      if "`e(sfirsteq)'" != "" & "`dropsfirst'" == "" {
      local savesfirst "savesfirst"
      }
      DispCollinDups
      }
    - else {
    - local cmdline `ivreg2name' `0'
    = local cmdline ivreg2 headroom mpg (weight = length), absorb(rep78)
    - checkversion_ranktest `ranktestcmd' `ranktestversion'
    = checkversion_ranktest ranktest 01.3.02
    - syntax [anything(name=0)] [if] [in] [aw fw pw iw/] [, NOID NOCOLLIN FIRST FFIRST SAVEFIRST SAVEFPrefix(name) RF SAVERF SAVERFPrefix
> (name) SFIRST SAVESFIRST SAVESFPrefix(name) SMall NOConstant Robust CLuster(varlist) kiefer dkraay(integer 0) BW(string) kernel(string)
>  center GMM GMM2s CUE LIML COVIV FULLER(real 0) Kclass(real 0) ORTHOG(string) ENDOGtest(string) REDundant(string) PARTIAL(string) FWL(s
> tring) Absorb(string) Level(integer $S_level) NOHEader NOFOoter NOOUTput bvclean NOOMITTED omitted vsquish noemptycells baselevels allb
> aselevels title(string) subtitle(string) DEPname(string) EForm(string) PLUS Tvar(varname) Ivar(varname) B0(string) SMATRIX(string) WMAT
> RIX(string) sw psd0 psda useqr dofminus(integer 0) sdofminus(integer 0) NOPARTIALSMALL fvall fvsep ]
    = syntax [anything(name=0)] [if] [in] [aw fw pw iw/] [, NOID NOCOLLIN FIRST FFIRST SAVEFIRST SAVEFPrefix(name) RF SAVERF SAVERFPrefix
> (name) SFIRST SAVESFIRST SAVESFPrefix(name) SMall NOConstant Robust CLuster(varlist) kiefer dkraay(integer 0) BW(string) kernel(string)
>  center GMM GMM2s CUE LIML COVIV FULLER(real 0) Kclass(real 0) ORTHOG(string) ENDOGtest(string) REDundant(string) PARTIAL(string) FWL(s
> tring) Absorb(string) Level(integer 95) NOHEader NOFOoter NOOUTput bvclean NOOMITTED omitted vsquish noemptycells baselevels allbaselev
> els title(string) subtitle(string) DEPname(string) EForm(string) PLUS Tvar(varname) Ivar(varname) B0(string) SMATRIX(string) WMATRIX(st
> ring) sw psd0 psda useqr dofminus(integer 0) sdofminus(integer 0) NOPARTIALSMALL fvall fvsep ]
    - if (`"`absorb'"' != "") {
    = if (`"rep78"' != "") {
    - capture which reghdfe
    - if c(rc) {
      di as err "Error: must have reghdfe installed"
      di as err "To install, from within Stata type " _c
      loc url "https://github.com/sergiocorreia/reghdfe/raw/version-4/src/"
      di in smcl `"{stata `"net install reghdfe, from(`url')"':net install reghdfe, from(`url')}"'
      exit 601
      }
    - cap reghdfe, requirements
    - if (c(rc)) reghdfe, requirements
option requirements not allowed
      reghdfe, check
      local small small
      local noconstant noconstant
      local nopartialsmall
      }
      sreturn clear
      ivparse `0', ivreg2name(`ivreg2name') partial(`partial') fwl(`fwl') orthog(`orthog') endogtest(`endogtest') redundant(`redundant') 
> depname(`depname') `robust' cluster(`cluster') bw(`bw') kernel(`kernel') dkraay(`dkraay') `center' `kiefer' `sw' `noconstant' tvar(`tva
> r') ivar(`ivar') `gmm2s' `gmm' `cue' `liml' fuller(`fuller') kclass(`kclass') b0(`b0') wmatrix(`wmatrix') `noid' `savefirst' savefprefi
> x(`savefprefix') `saverf' saverfprefix(`saverfprefix') `savesfirst' savesfprefix(`savesfprefix') dofminus(`dofminus') `psd0' `psda' `no
> collin' `useqr' `bvclean' eform(`eform') `noomitted' `vsquish' `noemptycells' `baselevels' `allbaselevels'
      local lhs `s(lhs)'
      local depname `s(depname)'
      local endo `s(endo)'
      local inexog `s(inexog)'
      local exexog `s(exexog)'
      local partial `s(partial)'
      local cons =s(cons)
      local partialcons =s(partialcons)
      local tvar `s(tvar)'
      local ivar `s(ivar)'
      local tdelta `s(tdelta)'
      local tsops =s(tsops)
      local fvops =s(fvops)
      local robust `s(robust)'
      local cluster `s(cluster)'
      local bw =`s(bw)'
      local bwopt `s(bwopt)'
      local kernel `s(kernel)'
      local center =`s(center)'
      local kclassopt `s(kclassopt)'
      local fulleropt `s(fulleropt)'
      local liml `s(liml)'
      local noid `s(noid)'
      local useqr =`s(useqr)'
      local savefirst `s(savefirst)'
      local savefprefix `s(savefprefix)'
      local saverf `s(saverf)'
      local saverfprefix `s(saverfprefix)'
      local savesfirst `s(savesfirst)'
      local savesfprefix `s(savesfprefix)'
      local psd `s(psd)'
      local dofmopt `s(dofmopt)'
      local bvclean =`s(bvclean)'
      local dispopt `s(dispopt)'
      if `tsops' | "`kernel'"~="" {
      cap tsset
      if _rc>0 {
      tsset `ivar' `tvar'
      }
      }
      tempvar wvar
      if "`weight'" == "fweight" | "`weight'"=="aweight" {
      local wtexp `"[`weight'=`exp']"'
      qui gen double `wvar'=`exp'
      }
      if "`weight'" == "fweight" & "`kernel'" !="" {
      di in red "fweights not allowed (data are -tsset-)"
      exit 101
      }
      if "`weight'" == "fweight" & "`sw'" != "" {
      di in red "fweights currently not supported with -sw- option"
      exit 101
      }
      if "`weight'" == "iweight" {
      if "`robust'`cluster'`gmm2s'`kernel'" !="" {
      di in red "iweights not allowed with robust or gmm"
      exit 101
      }
      else {
      local wtexp `"[`weight'=`exp']"'
      qui gen double `wvar'=`exp'
      }
      }
      if "`weight'" == "pweight" {
      local wtexp `"[aweight=`exp']"'
      qui gen double `wvar'=`exp'
      local robust "robust"
      }
      if "`weight'" == "" {
      qui gen byte `wvar'=1
      }
      marksample touse
      if `tsops' {
      markout `touse' `lhs' `inexog' `exexog' `endo' `cluster' `tvar', strok
      }
      else {
      markout `touse' `lhs' `inexog' `exexog' `endo' `cluster', strok
      }
      if (`"`absorb'"' != "") {
      mata: HDFE = fixed_effects("`absorb'", "`touse'", "`weight'", "`wvar'")
      _assert ("`s(options)'"==""), msg("unsupported options in {bf:absorb()}: `s(options)'")
      mata: HDFE.clustervars = HDFE.base_clustervars = tokens("`cluster'")
      mata: HDFE.num_clusters = length(HDFE.clustervars)
      mata: HDFE.estimate_dof()
      mata: HDFE.save_touse("`touse'", 1)
      }
      sum `wvar' if `touse' `wtexp', meanonly
      if "`weight'" ~= "" {
      di in gr "(sum of wgt is " %14.4e `r(sum_w)' ")"
      }
      if "`weight'"=="" | "`weight'"=="fweight" | "`weight'"=="iweight" {
      local wf=1
      local N=r(sum_w)
      }
      else if "`weight'"=="aweight" | "`weight'"=="pweight" {
      local wf=r(N)/r(sum_w)
      local N=r(N)
      }
      else {
      di as err "ivreg2 error - misspecified weights"
      exit 198
      }
      if `N'==0 {
      di as err "no observations"
      exit 2000
      }
      tempvar tindex
      qui gen `tindex'=1 if `touse'
      qui replace `tindex'=sum(`tindex') if `touse'
      if `tsops' | "`kernel'"~="" {
      tsreport if `touse', panel
      if `r(N_gaps)' != 0 {
      di as text "Warning: time variable " as res "`tvar'" as text " has " as res "`r(N_gaps)'" as text " gap(s) in relevant range"
      }
      sum `tvar' if `touse', meanonly
      local T = r(max)-r(min) + 1
      local T1 = `T' - 1
      if (`bw' > (`T1'/`tdelta')) {
      di as err "invalid bandwidth in option bw() - cannot exceed timespan of data"
      exit 198
      }
      }
      if "`kiefer'" ~= "" {
      local bw =`T'
      }
      if "`noconstant'"=="" {
      tempvar ones
      qui gen byte `ones' = 1 if `touse'
      }
      CheckDupsCollin, lhs(`lhs') endo(`endo') inexog(`inexog') exexog(`exexog') partial(`partial') orthog(`orthog') endogtest(`endogtest
> ') redundant(`redundant') touse(`touse') wvar(`wvar') wf(`wf') `noconstant' `nocollin' `fvall' `fvsep'
      foreach vl in lhs endo inexog exexog partial orthog endogtest redundant {
      local `vl' `s(`vl')'
      local `vl'0 `s(`vl'0)'
      }
      local dups `s(dups)'
      local collin `s(collin)'
      local ecollin `s(ecollin)'
      foreach vl in lhs endo inexog exexog partial orthog endogtest redundant {
      foreach var of local `vl'0 {
      _ms_parse_parts `var'
      if ~`r(omit)' {
      fvrevar `var' if `touse'
      local `vl'1 ``vl'1' `var'
      local fv_`vl'1 `fv_`vl'1' `r(varlist)'
      }
      }
      local `vl'1 : list retokenize `vl'1
      local fv_`vl'1 : list retokenize fv_`vl'1
      }
      local wrongvars_ct : word count `lhs'
      if `wrongvars_ct' > 1 {
      di as err "multiple dependent variables specified: `lhs'"
      error 198
      }
      local wrongvars : list orthog1 - inexog1
      local wrongvars : list wrongvars - exexog1
      local wrongvars_ct : word count `wrongvars'
      if `wrongvars_ct' {
      di as err "Error: `wrongvars' listed in orthog() but does not appear as exogenous."
      error 198
      }
      local wrongvars : list endogtest1 - endo1
      local wrongvars_ct : word count `wrongvars'
      if `wrongvars_ct' {
      di as err "Error: `wrongvars' listed in endog() but does not appear as endogenous."
      error 198
      }
      local wrongvars : list redundant1 - exexog1
      local wrongvars_ct : word count `wrongvars'
      if `wrongvars_ct' {
      di as err "Error: `wrongvars' listed in redundant() but does not appear as exogenous."
      error 198
      }
      local allnames `lhs' `endo' `inexog' `exexog'
      local allnames0 `lhs0' `endo0' `inexog0' `exexog0'
      local allnames1 `lhs1' `endo1' `inexog1' `exexog1'
      local fv_allnames1 `fv_lhs1' `fv_endo1' `fv_inexog1' `fv_exexog1'
      if "`partial1'" != "" | `partialcons'==1 | "`absorb'" != "" {
      preserve
      local inexog0 : list inexog0 - partial0
      local inexog1 : list inexog1 - partial1
      local fv_inexog1 : list fv_inexog1 - fv_partial1
      if "`cluster'"~="" {
      local pvarcheck : list cluster in allnames1
      if `pvarcheck' {
      di in r "Error: cannot use cluster variable `cluster' as dependent variable, regressor or IV"
      di in r "       in combination with -partial- option."
      error 198
      }
      }
      if "`tvar'"~="" {
      local pvarcheck : list tvar in allnames1
      if `pvarcheck' {
      di in r "Error: cannot use time variable `tvar' as dependent variable, regressor or IV"
      di in r "       in combination with -partial- option."
      error 198
      }
      }
      if "`ivar'"~="" {
      local pvarcheck : list ivar in allnames1
      if `pvarcheck' {
      di in r "Error: cannot use panel variable `ivar' as dependent variable, regressor or IV"
      di in r "       in combination with -partial- option."
      error 198
      }
      }
      if "`wtexp'"~="" {
      tokenize `exp', parse("*/()+-^&|~")
      local wvartokens `*'
      local nwvarnames : list allnames1 - wvartokens
      local wvarnames : list allnames1 - nwvarnames
      if "`wvarnames'"~="" {
      di in r "Error: cannot use weight variables as dependent variable, regressor or IV"
      di in r "       in combination with -partial- option."
      error 198
      }
      }
      recast double `fv_lhs1' `fv_endo1' `fv_inexog1' `fv_exexog1' `fv_partial1'
      if ("`absorb'" != "") {
      local hdfe_varlist `fv_lhs1' `fv_endo1' `fv_inexog1' `fv_exexog1' `fv_partial1'
      mata: st_store(HDFE.sample, tokens("`hdfe_varlist'"), HDFE.partial_out(tokens("`hdfe_varlist'")))
      mata: st_local("absorb_ct", strofreal(HDFE.df_a))
      assert `absorb_ct'`' != .
      if (`absorb_ct'==0) local absorb_ct 1
      local partial_ct 0
      local partialcons `absorb_ct'
      }
      if ("`partial1'" != "" | `partialcons'==1) {
      mata: s_partial ("`fv_lhs1'", "`fv_endo1'", "`fv_inexog1'", "`fv_exexog1'", "`fv_partial1'", "`touse'", "`weight'", "`wvar'", `wf',
>  `N', `cons')
      local partial_ct : word count `partial1'
      }
      capture drop `ones'
      local ones ""
      if "`noconstant'" == "" {
      local partial_ct = `partial_ct' + 1
      local noconstant "noconstant"
      local cons 0
      }
      if ("`absorb'" != "") {
      local partial_ct = `partial_ct' + `absorb_ct'
      }
      }
      else {
      local partial_ct 0
      local partialcons 0
      }
      if "`nopartialsmall'"=="" {
      local sdofminus = `sdofminus'+`partial_ct'
      }
      local rhs0 `endo0' `inexog0'
      local rhs1 `endo1' `inexog1'
      local insts1 `exexog1' `inexog1'
      local fv_insts1 `fv_exexog1' `fv_inexog1'
      local fv_rhs1 `fv_endo1' `fv_inexog1'
      local rhs0_ct : word count `rhs0'
      local rhs1_ct : word count `fv_rhs1'
      local iv1_ct : word count `fv_insts1'
      local endo1_ct : word count `fv_endo1'
      local exex1_ct : word count `fv_exexog1'
      local endoexex1_c : word count `fv_endo1' `fv_exexog1'
      local inexog1_ct : word count `fv_inexog1'
      local rhs1_ct = `rhs1_ct' + `cons'
      local rhs0_ct = `rhs0_ct' + `cons'
      local iv1_ct = `iv1_ct' + `cons'
      local cnb0 `endo0' `inexog0'
      local cnb1 `endo1' `inexog1'
      local cnZ0 `exexog0' `inexog0'
      local cnZ1 `exexog1' `inexog1'
      if `cons' {
      local cnb0 "`cnb0' _cons"
      local cnb1 "`cnb1' _cons"
      local cnZ0 "`cnZ0' _cons"
      local cnZ1 "`cnZ1' _cons"
      }
      CheckMisc, rhs1_ct(`rhs1_ct') iv1_ct(`iv1_ct') bvector(`b0') smatrix(`smatrix') wmatrix(`wmatrix') cnb1(`cnb1') cnZ1(`cnZ1')
      if "`b0'"~="" {
      tempname b0
      mat `b0' = r(b0)
      }
      if "`smatrix'"~="" {
      tempname S0
      mat `S0' = r(S0)
      }
      if "`wmatrix'"~="" {
      tempname wmatrix
      mat `wmatrix' = r(W0)
      }
      tempname YY yy yyc
      tempname XX X1X1 X2X2 X1Z X1Z1 XZ Xy
      tempname ZZ Z1Z1 Z2Z2 Z1Z2 Z1X2 Zy ZY Z2y Z2Y
      tempname XXinv X2X2inv ZZinv XPZXinv
      tempname rankxx rankzz condxx condzz
      mata: s_crossprods ("`fv_lhs1'", "`fv_endo1'", "`fv_inexog1' `ones'", "`fv_exexog1'", "`touse'", "`weight'", "`wvar'", `wf', `N')
      mat `XX' =r(XX)
      mat `X1X1' =r(X1X1)
      mat `X1Z' =r(X1Z)
      mat `ZZ' =r(ZZ)
      mat `Z2Z2' =r(Z2Z2)
      mat `Z1Z2' =r(Z1Z2)
      mat `XZ' =r(XZ)
      mat `Xy' =r(Xy)
      mat `Zy' =r(Zy)
      mat `YY' =r(YY)
      scalar `yy' =r(yy)
      scalar `yyc' =r(yyc)
      mat `ZY' =r(ZY)
      mat `Z2y' =r(Z2y)
      mat `Z2Y' =r(Z2Y)
      mat `XXinv' =r(XXinv)
      mat `ZZinv' =r(ZZinv)
      mat `XPZXinv' =r(XPZXinv)
      scalar `condxx' =r(condxx)
      scalar `condzz' =r(condzz)
      scalar `rankzz' = rowsof(`ZZinv') - diag0cnt(`ZZinv')
      scalar `rankxx' = rowsof(`XXinv') - diag0cnt(`XXinv')
      local overid = `rankzz' - `rankxx'
      local N_clust=0
      local N_clust1=0
      local N_clust2=0
      if "`cluster'"!="" {
      local clopt "cluster(`cluster')"
      tokenize `cluster'
      local cluster1 "`1'"
      local cluster2 "`2'"
      if "`kernel'"~="" {
      if "`cluster2'"~="" {
      if "`cluster1'"=="`tvar'" & "`cluster2'"=="`ivar'" {
      local cluster1 "`2'"
      local cluster2 "`1'"
      }
      if "`cluster1'"~="`ivar'" | "`cluster2'"~="`tvar'" {
      di as err "Error: cluster kernel-robust requires clustering on tsset panel & time vars."
      di as err "       tsset panel var=`ivar'; tsset time var=`tvar'; cluster vars=`cluster1',`cluster2'"
      exit 198
      }
      }
      else {
      if "`cluster1'"~="`tvar'" {
      di as err "Error: cluster kernel-robust requires clustering on tsset time variable."
      di as err "       tsset time var=`tvar'; cluster var=`cluster1'"
      exit 198
      }
      }
      }
      tempvar clusterid1
      qui egen `clusterid1'=group(`cluster1') if `touse'
      sum `clusterid1' if `touse', meanonly
      if "`cluster2'"=="" {
      local N_clust=r(max)
      local N_clust1=`N_clust'
      if "`kernel'"=="" {
      sort `cluster1'
      }
      }
      else {
      local N_clust1=r(max)
      if "`kernel'"=="" {
      tempvar clusterid2 clusterid3
      qui egen `clusterid2'=group(`cluster2') if `touse'
      qui egen `clusterid3'=group(`cluster1' `cluster2') if `touse'
      sort `clusterid3' `cluster1'
      sum `clusterid2' if `touse', meanonly
      local N_clust2=r(max)
      }
      else {
      tempvar clusterid2
      qui egen `clusterid2'=group(`cluster2') if `touse'
      sum `clusterid2' if `touse', meanonly
      local N_clust2=r(max)
      local clusterid2 `cluster2'
      }
      local N_clust=min(`N_clust1',`N_clust2')
      }
      }
      tempname b W S V beta lambda j jp rss mss rmse sigmasq rankV rankS
      tempname arubin arubinp arubin_lin arubin_linp
      tempname r2 r2_a r2u r2c F Fp Fdf2 ivest
      tempvar resid
      qui gen double `resid'=.
      if "`liml'`kclassopt'"~="" {
      mata: s_liml( "`ZZ'", "`XX'", "`XZ'", "`Zy'", "`Z2Z2'", "`YY'", "`ZY'", "`Z2Y'", "`Xy'", "`ZZinv'", "`fv_lhs1'", "`fv_lhs1' `fv_end
> o1'", "`resid'", "`fv_endo1' `fv_inexog1' `ones'", "`fv_endo1'", "`fv_exexog1' `fv_inexog1' `ones'", "`fv_exexog1'", "`fv_inexog1' `one
> s'", `fuller', `kclass', "`coviv'", "`touse'", "`weight'", "`wvar'", `wf', `N', "`robust'", "`clusterid1'", "`clusterid2'", "`clusterid
> 3'", `bw', "`kernel'", "`sw'", "`psd'", "`ivar'", "`tvar'", "`tindex'", `tdelta', `center', `dofminus', `useqr')
      mat `b'=r(beta)
      mat `S'=r(S)
      mat `V'=r(V)
      scalar `lambda'=r(lambda)
      local kclass=r(kclass)
      scalar `j'=r(j)
      scalar `rss'=r(rss)
      scalar `sigmasq'=r(sigmasq)
      scalar `rankV'=r(rankV)
      scalar `rankS'=r(rankS)
      scalar `arubin'=(`N'-`dofminus')*ln(`lambda')
      scalar `arubin_lin'=(`N'-`dofminus')*(`lambda'-1)
      if "`nocollin'"~="" & `kclass'<1e-8 {
      di as err "warning: k=1 in LIML estimation; results equivalent to OLS;"
      di as err "         may be caused by collinearities"
      }
      }
      if "`liml'`kclassopt'`b0'"=="" {
      local effic1s = ( "`gmm2s'`robust'`cluster'`kernel'"=="" | ("`smatrix'"~="" & "`wmatrix'"=="") )
      mata: s_gmm1s( "`ZZ'", "`XX'", "`XZ'", "`Zy'", "`ZZinv'", "`fv_lhs1'", "`resid'", "`fv_endo1' `fv_inexog1' `ones'", "`fv_exexog1' `
> fv_inexog1' `ones'", "`touse'", "`weight'", "`wvar'", `wf', `N', "`wmatrix'", "`S0'", `dofminus', `effic1s', `overid', `useqr')
      mat `b'=r(beta)
      mat `W'=r(W)
      if `effic1s' {
      mat `V'=r(V)
      mat `S'=r(S)
      scalar `j'=r(j)
      scalar `rss'=r(rss)
      scalar `sigmasq'=r(sigmasq)
      scalar `rankV'=r(rankV)
      scalar `rankS'=r(rankS)
      }
      else {
      tempname QXZ_W_QZX
      mat `QXZ_W_QZX'=r(QXZ_W_QZX)
      if "`smatrix'"~="" {
      mat `S'=`S0'
      }
      else {
      if `bw' != 0 {
      if `bw' == -1 {
      tempvar abwtouse
      gen byte `abwtouse' = (`resid' < .)
      abw `resid' `exexog1' `inexog1' `abwtouse', tindex(`tindex') nobs(`N') tobs(`T') noconstant kernel(`kernel')
      local bw `r(abw)'
      local bwopt "bw(`bw')"
      local bwchoice "`r(bwchoice)'"
      }
      }
      mata: s_omega( "`ZZ'", "`resid'", "`fv_exexog1' `fv_inexog1' `ones'", "`touse'", "`weight'", "`wvar'", `wf', `N', "`robust'", "`clu
> sterid1'", "`clusterid2'", "`clusterid3'", `bw', "`kernel'", "`sw'", "`psd'", "`ivar'", "`tvar'", "`tindex'", `tdelta', `center', `dofm
> inus')
      mat `S'=r(S)
      }
      if "`gmm2s'"=="" & "`robust'`cluster'`kernel'"~="" {
      mata: s_iegmm( "`ZZ'", "`XX'", "`XZ'", "`Zy'", "`QXZ_W_QZX'", "`fv_lhs1'", "`resid'", "`fv_endo1' `fv_inexog1' `ones'", "`fv_exexog
> 1' `fv_inexog1' `ones'", "`touse'", "`weight'", "`wvar'", `wf', `N', "`W'", "`S'", "`b'", `dofminus', `overid', `useqr')
      }
      if "`gmm2s'"~="" {
      mata: s_egmm( "`ZZ'", "`XX'", "`XZ'", "`Zy'", "`ZZinv'", "`fv_lhs1'", "`resid'", "`fv_endo1' `fv_inexog1' `ones'", "`fv_exexog1' `f
> v_inexog1' `ones'", "`touse'", "`weight'", "`wvar'", `wf', `N', "`S'", `dofminus', `overid', `useqr')
      mat `b'=r(beta)
      mat `W'=r(W)
      }
      mat `V'=r(V)
      scalar `j'=r(j)
      scalar `rss'=r(rss)
      scalar `sigmasq'=r(sigmasq)
      scalar `rankV'=r(rankV)
      scalar `rankS'=r(rankS)
      }
      }
      if "`cue'`b0'" != "" {
      mata: s_gmmcue( "`ZZ'", "`XZ'", "`fv_lhs1'", "`resid'", "`fv_endo1' `fv_inexog1' `ones'", "`fv_exexog1' `fv_inexog1' `ones'", "`tou
> se'", "`weight'", "`wvar'", `wf', `N', "`robust'", "`clusterid1'", "`clusterid2'", "`clusterid3'", `bw', "`kernel'", "`sw'", "`psd'", "
> `ivar'", "`tvar'", "`tindex'", `tdelta', "`b'", "`b0'", `center', `dofminus', `useqr')
      mat `b'=r(beta)
      mat `S'=r(S)
      mat `W'=r(W)
      mat `V'=r(V)
      scalar `j'=r(j)
      scalar `rss'=r(rss)
      scalar `sigmasq'=r(sigmasq)
      scalar `rankV'=r(rankV)
      scalar `rankS'=r(rankS)
      }
      mat colnames `b' = `cnb1'
      mat colnames `V' = `cnb1'
      mat rownames `V' = `cnb1'
      mat colnames `S' = `cnZ1'
      mat rownames `S' = `cnZ1'
      capture mat colnames `W' = `cnZ1'
      capture mat rownames `W' = `cnZ1'
      if (`"`absorb'"' != "") {
      mata: HDFE.residuals = (HDFE.residuals == "" & HDFE.save_any_fe) ? "__temp_reghdfe_resid__" : HDFE.residuals
      mata: st_local("residuals_name", HDFE.residuals)
      if ("`residuals_name'" != "") mata: hdfe_residuals = st_data(., "`resid'", "`touse'")
      }
      scalar `rmse'=sqrt(`sigmasq')
      if "`noconstant'"=="" {
      scalar `mss'=`yyc' - `rss'
      }
      else {
      scalar `mss'=`yy' - `rss'
      }
      local Fdf1 = `rankxx' - `cons'
      local df_m = `rankxx' - `cons' + (`sdofminus'-`partialcons')
      if "`cluster'"=="" {
      local df_r = int(`N') - `rankxx' - `dofminus' - `sdofminus'
      }
      else {
      local df_r = `N_clust' - 1
      }
      local jdf = `rankzz' - `rankxx'
      if `jdf' == 0 & "`b0'"=="" {
      scalar `j' = 0
      }
      else {
      scalar `jp' = chiprob(`jdf',`j')
      }
      if "`liml'"~="" {
      scalar `arubinp' = chiprob(`jdf',`arubin')
      scalar `arubin_linp' = chiprob(`jdf',`arubin_lin')
      }
      if "`small'" != "" {
      if "`cluster'"=="" {
      matrix `V'=`V'*(`N'-`dofminus')/(`N'-`rankxx'-`dofminus'-`sdofminus')
      }
      else {
      matrix `V'=`V'*(`N'-1)/(`N'-`rankxx'-`sdofminus') * `N_clust'/(`N_clust'-1)
      }
      scalar `sigmasq'=`rss'/(`N'-`rankxx'-`dofminus'-`sdofminus')
      scalar `rmse'=sqrt(`sigmasq')
      }
      scalar `r2u'=1-`rss'/`yy'
      scalar `r2c'=1-`rss'/`yyc'
      if "`noconstant'"=="" {
      scalar `r2'=`r2c'
      scalar `r2_a'=1-(1-`r2')*(`N'-1)/(`N'-`rankxx'-`dofminus'-`sdofminus')
      }
      else {
      scalar `r2'=`r2u'
      scalar `r2_a'=1-(1-`r2')*`N'/(`N'-`rankxx'-`dofminus'-`sdofminus')
      }
      local N=int(`N')
      tempname FB FV
      mat `FB'=`b'
      mat `FV'=`V'
      capture ereturn post `FB' `FV'
      local rc = _rc
      if `rc' != 506 {
      ivreg2_fvstrip `rhs1', dropomit
      capture test `r(varlist)'
      if "`small'" == "" {
      if "`cluster'"=="" {
      capture scalar `F' = r(chi2)/`Fdf1' * `df_r'/(`N'-`dofminus')
      }
      else {
      capture scalar `F' = r(chi2)/`Fdf1' * (`N_clust'-1)/`N_clust' * (`N'-`rankxx'-`sdofminus')/(`N'-1)
      }
      }
      else {
      capture scalar `F' = r(chi2)/`Fdf1'
      }
      capture scalar `Fp'=Ftail(`Fdf1',`df_r',`F')
      capture scalar `Fdf2'=`df_r'
      }
      if `j' == . | `rc'==506 {
      scalar `F' = .
      scalar `Fp' = .
      }
      if "`sfirst'`savesfirst'`rf'`saverf'`first'`ffirst'`savefirst'" != "" & (`endo1_ct' > 0) {
      capture tsset
      local sdofmopt = "sdofminus(`sdofminus')"
      tempname fsres1
      qui gen double `fsres1'=.
      local fsresall `fsres1'
      foreach x of local fv_endo1 {
      tempname fsres
      qui gen double `fsres'=.
      local fsresall "`fsresall' `fsres'"
      }
      if "`cluster'"!="" {
      sort `clusterid3' `cluster1'
      }
      mata: s_ffirst( "`ZZ'", "`XX'", "`XZ'", "`ZY'", "`ZZinv'", "`XXinv'", "`XPZXinv'", "`Z2Z2'", "`Z1Z2'", "`Z2y'", "`fsres1'", "`fsres
> all'", "`fv_lhs1'", "`fv_endo1'", "`fv_inexog1' `ones'", "`fv_exexog1'", "`touse'", "`weight'", "`wvar'", `wf', `N', `N_clust', "`robus
> t'", "`clusterid1'", "`clusterid2'", "`clusterid3'", `bw', "`kernel'", "`sw'", "`psd'", "`ivar'", "`tvar'", "`tindex'", `tdelta', `cent
> er', `dofminus', `sdofminus')
      tempname firstmat firstb firstv firsts
      mat `firstmat' = r(firstmat)
      mat rowname `firstmat' = rmse sheapr2 pr2 F df df_r pvalue SWF SWFdf1 SWFdf2 SWFp SWchi2 SWchi2p SWr2 APF APFdf1 APFdf2 APFp APchi2
>  APchi2p APr2
      mat colname `firstmat' = `endo1'
      mat `firstb' = r(b)
      mat `firstv' = r(V)
      mat `firsts' = r(S)
      local archi2 =r(archi2)
      local archi2p =r(archi2p)
      local arf =r(arf)
      local arfp =r(arfp)
      local ardf =r(ardf)
      local ardf_r =r(ardf_r)
      local sstat =r(sstat)
      local sstatdf =r(sstatdf)
      local sstatp =r(sstatp)
      local rmse_rf =r(rmse_rf)
      capture tsset
      if "`sfirst'`savesfirst'" ~= "" {
      PostFirstRF if `touse', bmat(`firstb') vmat(`firstv') smat(`firsts') firstmat(`firstmat') lhs1(`lhs1') endo1(`endo1') znames0(`cnZ0
> ') znames1(`cnZ1') bvclean(`bvclean') fvops(`fvops') partial_ct(`partial_ct') `robust' cluster(`cluster') cluster1(`cluster1') cluster2
> (`cluster2') nc(`N_clust') nc1(`N_clust1') nc2(`N_clust2') kernel(`kernel') bw(`bw') ivar(`ivar') tvar(`tvar') obs(`N') iv1_ct(`iv1_ct'
> ) cons(`cons') partialcons(`partialcons') dofminus(`dofminus') sdofminus(`sdofminus')
      local sfirsteq "`savesfprefix'sfirst_`lhs1'"
      local sfirsteq : subinstr local sfirsteq "." "_"
      capture est store `sfirsteq', title("System of first-stage/reduced form regressions")
      if _rc > 0 {
      di
      di in ye "Unable to store system of first-stage reduced form regressions."
      di
      }
      }
      if "`rf'`saverf'" ~= "" {
      PostFirstRF if `touse', rf rmse_rf(`rmse_rf') bmat(`firstb') vmat(`firstv') smat(`firsts') firstmat(`firstmat') lhs1(`lhs1') endo1(
> `endo1') znames0(`cnZ0') znames1(`cnZ1') bvclean(`bvclean') fvops(`fvops') partial_ct(`partial_ct') `robust' cluster(`cluster') cluster
> 1(`cluster1') cluster2(`cluster2') nc(`N_clust') nc1(`N_clust1') nc2(`N_clust2') kernel(`kernel') bw(`bw') ivar(`ivar') tvar(`tvar') ob
> s(`N') iv1_ct(`iv1_ct') cons(`cons') partialcons(`partialcons') dofminus(`dofminus') sdofminus(`sdofminus')
      local rfeq "`saverfprefix'`lhs1'"
      local rfeq : subinstr local rfeq "." "_"
      capture est store `rfeq', title("Reduced-form regression: `lhs'")
      if _rc > 0 {
      di
      di in ye "Unable to store reduced form regression of `lhs1'."
      di
      }
      }
      if "`first'`savefirst'" ~= "" {
      foreach vn in `endo1' {
      PostFirstRF if `touse', first(`vn') bmat(`firstb') vmat(`firstv') smat(`firsts') firstmat(`firstmat') lhs1(`lhs1') endo1(`endo1') z
> names0(`cnZ0') znames1(`cnZ1') bvclean(`bvclean') fvops(`fvops') partial_ct(`partial_ct') `robust' cluster(`cluster') cluster1(`cluster
> 1') cluster2(`cluster2') nc(`N_clust') nc1(`N_clust1') nc2(`N_clust2') kernel(`kernel') bw(`bw') ivar(`ivar') tvar(`tvar') obs(`N') iv1
> _ct(`iv1_ct') cons(`cons') partialcons(`partialcons') dofminus(`dofminus') sdofminus(`sdofminus')
      local eqname "`savefprefix'`vn'"
      local eqname : subinstr local eqname "." "_"
      capture est store `eqname', title("First-stage regression: `vn'")
      if _rc == 0 {
      local firsteqs "`firsteqs' `eqname'"
      }
      else {
      di
      di in ye "Unable to store first-stage regression of `vn'."
      di
      }
      }
      }
      }
      capture tsset
      if "`orthog'"!="" {
      tempname cj cstat cstatp
      scalar `cstat' = 0
      local cexexog1 : list fv_exexog1 - fv_orthog1
      local cinexog1 : list fv_inexog1 - fv_orthog1
      local cendo1 : list fv_inexog1 - cinexog1
      local cendo1 `fv_endo1' `cendo1'
      local clist_ct : word count `orthog1'
      capture _estimates hold `ivest', restore
      if _rc==1000 {
      di as err "ivreg2 internal error - no room to save temporary estimation results"
      di as err "Please drop one or more estimation results using -estimates drop-"
      exit 1000
      }
      tempname fv_S
      mat `fv_S'=`S'
      if `cons' {
      mat colnames `fv_S' = `fv_exexog1' `fv_inexog1' _cons
      mat rownames `fv_S' = `fv_exexog1' `fv_inexog1' _cons
      }
      else {
      mat colnames `fv_S' = `fv_exexog1' `fv_inexog1'
      mat rownames `fv_S' = `fv_exexog1' `fv_inexog1'
      }
      capture `ivreg2cmd' `fv_lhs1' `cinexog1' (`cendo1'=`cexexog1') if `touse' `wtexp', `noconstant' `options' `small' `robust' `gmm2s' 
> `bwopt' `kernopt' `dofmopt' `sw' `psd' smatrix("`fv_S'") noid nocollin
      local rc = _rc
      if `rc' == 481 {
      scalar `cstat' = 0
      local cstatdf = 0
      }
      else {
      scalar `cj'=e(j)
      local cjdf=e(jdf)
      scalar `cstat' = `j' - `cj'
      local cstatdf = `jdf' - `cjdf'
      }
      _estimates unhold `ivest'
      scalar `cstatp'= chiprob(`cstatdf',`cstat')
      if `cstatdf' != `clist_ct' {
      scalar `cstat' = 0
      }
      }
      if "`endogtest'"!="" {
      tempname estat estatp
      scalar `estat' = 0
      local eendo1 : list fv_endo1 - fv_endogtest1
      local einexog1 `fv_inexog1' `fv_endogtest1'
      local elist_ct : word count `endogtest1'
      capture {
      capture _estimates hold `ivest', restore
      if _rc==1000 {
      di as err "ivreg2 internal error - no room to save temporary estimation results"
      di as err "Please drop one or more estimation results using -estimates drop-"
      exit 1000
      }
      capture `ivreg2cmd' `fv_lhs1' `einexog1' (`eendo1'=`fv_exexog1') if `touse' `wtexp', `noconstant' `robust' `clopt' `gmm2s' `liml' `
> bwopt' `kernopt' `small' `dofmopt' `sw' `psd' `options' orthog(`fv_endogtest1') noid nocollin
      local rc = _rc
      if `rc' == 481 {
      scalar `estat' = 0
      local estatdf = 0
      }
      else {
      scalar `estat'=e(cstat)
      local estatdf=e(cstatdf)
      scalar `estatp'=e(cstatp)
      }
      _estimates unhold `ivest'
      if `estatdf' != `elist_ct' {
      scalar `estat' = 0
      }
      }
      }
      if `endo1_ct' > 0 & "`noid'"=="" {
      tempname idrkstat widrkstat iddf idp
      tempname ccf cdf rkf cceval cdeval cd
      tempname idstat widstat
      cap `ranktestcmd' (`fv_endo1') (`fv_exexog1') `wtexp' if `touse', partial(`fv_inexog1') full `noconstant' `robust' `clopt' `bwopt' 
> `kernopt'
      local rkerror = _rc>0 | r(chi2)==.
      if ~`rkerror' {
      local rkerror = el(r(ccorr),1,1)==1
      }
      if `rkerror' {
      di as err "warning: -ranktest- error in calculating underidentification test statistics;"
      di as err "         may be caused by collinearities"
      scalar `idstat' = .
      local iddf = .
      scalar `idp' = .
      scalar `cd' = .
      scalar `cdf' = .
      }
      else {
      if "`cluster'"=="" {
      scalar `idstat'=r(chi2)/r(N)*(`N'-`dofminus')
      }
      else {
      scalar `idstat'=r(chi2)
      }
      mat `cceval'=r(ccorr)
      mat `cdeval' = J(1,`endo1_ct',.)
      forval i=1/`endo1_ct' {
      mat `cceval'[1,`i'] = (`cceval'[1,`i'])^2
      mat `cdeval'[1,`i'] = `cceval'[1,`i'] / (1 - `cceval'[1,`i'])
      }
      local iddf = `iv1_ct' - (`rhs1_ct'-1)
      scalar `idp' = chiprob(`iddf',`idstat')
      scalar `cd'=`cdeval'[1,`endo1_ct']
      scalar `cdf'=`cd'*(`N'-`sdofminus'-`iv1_ct'-`dofminus')/`exex1_ct'
      }
      if "`robust'`cluster'`kernel'"=="" {
      scalar `widstat'=`cdf'
      }
      else {
      cap `ranktestcmd' (`fv_endo1') (`fv_exexog1') `wtexp' if `touse', partial(`fv_inexog1') full wald `noconstant' `robust' `clopt' `bw
> opt' `kernopt'
      local rkerror = _rc>0 | r(chi2)==.
      if ~`rkerror' {
      local rkerror = el(r(ccorr),1,1)==1
      }
      if `rkerror' {
      di as err "warning: -ranktest- error in calculating weak identification test statistics;"
      di as err "         may be caused by collinearities"
      scalar `rkf' = .
      scalar `widstat' = .
      }
      else {
      if "`cluster'"=="" {
      scalar `rkf'=r(chi2)/r(N)*(`N'-`iv1_ct'-`sdofminus'-`dofminus')/`exex1_ct'
      }
      else {
      scalar `rkf' = r(chi2)/(`N'-1) * (`N'-`iv1_ct'-`sdofminus') * (`N_clust'-1)/`N_clust' / `exex1_ct'
      }
      scalar `widstat'=`rkf'
      }
      }
      }
      if `endo1_ct' > 0 & "`redundant'" ~= "" & "`noid'"=="" {
      local rexexog1 : list fv_exexog1 - fv_redundant1
      local redlist_ct : word count `redundant1'
      tempname rkmatrix
      qui `ranktestcmd' (`fv_endo1') (`fv_redundant1') `wtexp' if `touse', partial(`fv_inexog1' `rexexog1') null `noconstant' `robust' `c
> lopt' `bwopt' `kernopt'
      mat `rkmatrix'=r(rkmatrix)
      tempname redstat redp
      if "`cluster'"=="" {
      scalar `redstat' = `rkmatrix'[1,1]/r(N)*(`N'-`dofminus')
      }
      else {
      scalar `redstat' = `rkmatrix'[1,1]
      }
      local reddf = `endo1_ct'*`redlist_ct'
      scalar `redp' = chiprob(`reddf',`redstat')
      }
      if `N' <= `iv1_ct' {
      di in r "Error: number of observations must be greater than number of instruments"
      di in r "       including constant."
      error 2001
      }
      if ("`gmm2s'`robust'`cluster'`kernel'" != "") & (`rankS' < `iv1_ct') {
      scalar `j' = .
      if "`orthog'"!="" {
      scalar `cstat' = .
      }
      if "`endogtest'"!="" {
      scalar `estat' = .
      }
      }
      if ~`bvclean' & (`rhs0_ct' > `rhs1_ct') {
      AddOmitted, bmat(`b') vmat(`V') cnb0(`cnb0') cnb1(`cnb1')
      mat `b' = r(b)
      mat `V' = r(V)
      if `fvops' & ~`partial_ct' {
      local bfv "buildfvinfo"
      }
      }
      if (`partial_ct' | "`absorb'"!="") {
      restore
      }
      if "`small'"!="" {
      local NminusK = `N'-`rankxx'-`sdofminus'
      capture ereturn post `b' `V', dep(`depname') obs(`N') esample(`touse') dof(`NminusK') `bfv'
      }
      else {
      capture ereturn post `b' `V', dep(`depname') obs(`N') esample(`touse') `bfv'
      }
      local rc = _rc
      if `rc' == 504 {
      di in red "Error: estimated variance-covariance matrix has missing values"
      exit 504
      }
      if `rc' == 506 {
      di in red "Error: estimated variance-covariance matrix not positive-definite"
      exit 506
      }
      if `rc' > 0 {
      di in red "Error: estimation failed - could not post estimation results"
      exit `rc'
      }
      local mok =1
      local mok = `mok' & ~`partial_ct'
      local mok = `mok' & ~(`fvops' & `bvclean')
      if `mok' & `endo1_ct' {
      ereturn local marginsnotok "Residuals SCores"
      ereturn local marginsok "XB default"
      }
      else if `mok' & ~`endo1_ct' {
      ereturn local marginsok "XB default"
      }
      else {
      ereturn local marginsnotok "Residuals SCores XB default"
      }
      ereturn local ecollin `ecollin'
      ereturn local collin `collin'
      ereturn local dups `dups'
      ereturn local partial1 `partial1'
      ereturn local partial `partial'
      ereturn local inexog1 `inexog1'
      ereturn local inexog0 `inexog0'
      ereturn local inexog `inexog'
      ereturn local exexog1 `exexog1'
      ereturn local exexog0 `exexog0'
      ereturn local exexog `exexog'
      ereturn local insts1 `exexog1' `inexog1'
      ereturn local insts0 `exexog0' `inexog0'
      ereturn local insts `exexog' `inexog'
      ereturn local instd1 `endo1'
      ereturn local instd0 `endo0'
      ereturn local instd `endo'
      ereturn local depvar1 `lhs1'
      ereturn local depvar0 `lhs0'
      ereturn local depvar `lhs'
      ereturn scalar inexog_ct =`inexog1_ct'
      ereturn scalar exexog_ct =`exex1_ct'
      ereturn scalar endog_ct =`endo1_ct'
      ereturn scalar partial_ct =`partial_ct'
      if "`smatrix'" == "" {
      ereturn matrix S `S'
      }
      else {
      ereturn matrix S `S0'
      }
      if "`wmatrix'"=="" & "`liml'`kclassopt'"=="" {
      ereturn matrix W `W'
      }
      else if "`liml'`kclassopt'"=="" {
      ereturn matrix W `wmatrix'
      }
      if "`kernel'"!="" {
      ereturn local kernel "`kernel'"
      ereturn scalar bw=`bw'
      ereturn local tvar "`tvar'"
      if "`ivar'" ~= "" {
      ereturn local ivar "`ivar'"
      }
      if "`bwchoice'" ~= "" {
      ereturn local bwchoice "`bwchoice'"
      }
      }
      if "`small'"!="" {
      ereturn scalar df_r=`df_r'
      ereturn local small "small"
      }
      if "`nopartialsmall'"=="" {
      ereturn local partialsmall "small"
      }
      if "`robust'" != "" {
      local vce "robust"
      }
      if "`cluster1'" != "" {
      if "`cluster2'"=="" {
      local vce "`vce' cluster"
      }
      else {
      local vce "`vce' two-way cluster"
      }
      }
      if "`kernel'" != "" {
      if "`robust'" != "" {
      local vce "`vce' hac"
      }
      else {
      local vce "`vce' ac"
      }
      local vce "`vce' `kernel' bw=`bw'"
      }
      if "`sw'" != "" {
      local vce "`vce' sw"
      }
      if "`psd'" != "" {
      local vce "`vce' `psd'"
      }
      local vce : list clean vce
      local vce = lower("`vce'")
      ereturn local vce `vce'
      if "`cluster'"!="" {
      ereturn scalar N_clust=`N_clust'
      ereturn local clustvar `cluster'
      }
      if "`cluster2'"!="" {
      ereturn scalar N_clust1=`N_clust1'
      ereturn scalar N_clust2=`N_clust2'
      ereturn local clustvar1 `cluster1'
      ereturn local clustvar2 `cluster2'
      }
      if "`robust'`cluster'" != "" {
      ereturn local vcetype "Robust"
      }
      ereturn scalar df_m=`df_m'
      ereturn scalar sdofminus=`sdofminus'
      ereturn scalar dofminus=`dofminus'
      ereturn scalar center=`center'
      ereturn scalar r2=`r2'
      ereturn scalar rmse=`rmse'
      ereturn scalar rss=`rss'
      ereturn scalar mss=`mss'
      ereturn scalar r2_a=`r2_a'
      ereturn scalar F=`F'
      ereturn scalar Fp=`Fp'
      ereturn scalar Fdf1=`Fdf1'
      ereturn scalar Fdf2=`Fdf2'
      ereturn scalar yy=`yy'
      ereturn scalar yyc=`yyc'
      ereturn scalar r2u=`r2u'
      ereturn scalar r2c=`r2c'
      ereturn scalar condzz=`condzz'
      ereturn scalar condxx=`condxx'
      ereturn scalar rankzz=`rankzz'
      ereturn scalar rankxx=`rankxx'
      ereturn scalar rankS=`rankS'
      ereturn scalar rankV=`rankV'
      ereturn scalar ll = -0.5 * (`N'*ln(2*_pi) + `N'*ln(`rss'/`N') + `N')
      ereturn scalar j=`j'
      ereturn scalar jdf=`jdf'
      if `j' != 0 & `j' != . {
      ereturn scalar jp=`jp'
      }
      if ("`robust'`cluster'"=="") {
      ereturn scalar sargan=`j'
      ereturn scalar sargandf=`jdf'
      if `j' != 0 & `j' != . {
      ereturn scalar sarganp=`jp'
      }
      }
      if "`liml'"!="" {
      ereturn scalar arubin=`arubin'
      ereturn scalar arubin_lin=`arubin_lin'
      if `j' != 0 & `j' != . {
      ereturn scalar arubinp=`arubinp'
      ereturn scalar arubin_linp=`arubin_linp'
      }
      ereturn scalar arubindf=`jdf'
      }
      if "`orthog'"!="" {
      ereturn scalar cstat=`cstat'
      if `cstat'!=0 & `cstat' != . {
      ereturn scalar cstatp=`cstatp'
      ereturn scalar cstatdf=`cstatdf'
      ereturn local clist `orthog1'
      }
      }
      if "`endogtest'"!="" {
      ereturn scalar estat=`estat'
      if `estat'!=0 & `estat' != . {
      ereturn scalar estatp=`estatp'
      ereturn scalar estatdf=`estatdf'
      ereturn local elist `endogtest1'
      }
      }
      if `endo1_ct' > 0 & "`noid'"=="" {
      ereturn scalar idstat=`idstat'
      ereturn scalar iddf=`iddf'
      ereturn scalar idp=`idp'
      ereturn scalar cd=`cd'
      ereturn scalar widstat=`widstat'
      ereturn scalar cdf=`cdf'
      capture ereturn matrix ccev=`cceval'
      capture ereturn matrix cdev `cdeval'
      capture ereturn scalar rkf=`rkf'
      }
      if "`redundant'"!="" & "`noid'"=="" {
      ereturn scalar redstat=`redstat'
      ereturn scalar redp=`redp'
      ereturn scalar reddf=`reddf'
      ereturn local redlist `redundant1'
      }
      if "`first'`ffirst'`savefirst'`sfirst'`savesfirst'" != "" & `endo1_ct'>0 {
      capture ereturn matrix first `firstmat'
      ereturn scalar arf=`arf'
      ereturn scalar arfp=`arfp'
      ereturn scalar archi2=`archi2'
      ereturn scalar archi2p=`archi2p'
      ereturn scalar ardf=`ardf'
      ereturn scalar ardf_r=`ardf_r'
      ereturn scalar sstat=`sstat'
      ereturn scalar sstatp=`sstatp'
      ereturn scalar sstatdf=`sstatdf'
      }
      ereturn local firsteqs `firsteqs'
      ereturn local rfeq `rfeq'
      ereturn local sfirsteq `sfirsteq'
      if "`liml'"!="" {
      ereturn local model "liml"
      ereturn scalar kclass=`kclass'
      ereturn scalar lambda=`lambda'
      if `fuller' > 0 & `fuller' < . {
      ereturn scalar fuller=`fuller'
      }
      }
      else if "`kclassopt'" != "" {
      ereturn local model "kclass"
      ereturn scalar kclass=`kclass'
      }
      else if "`gmm2s'`cue'`b0'`wmatrix'"=="" {
      if "`endo1'" == "" {
      ereturn local model "ols"
      }
      else {
      ereturn local model "iv"
      }
      }
      else if "`cue'`b0'"~="" {
      ereturn local model "cue"
      }
      else if "`gmm2s'"~="" {
      ereturn local model "gmm2s"
      }
      else if "`wmatrix'"~="" {
      ereturn local model "gmmw"
      }
      else {
      ereturn local model "unknown"
      }
      if "`weight'" != "" {
      ereturn local wexp "=`exp'"
      ereturn local wtype `weight'
      }
      ereturn local cmd `ivreg2cmd'
      ereturn local cmdline `cmdline'
      ereturn local version `lversion'
      ereturn scalar nocollin =("`nocollin'"~="")
      ereturn scalar partialcons =`partialcons'
      ereturn scalar cons =`cons'
      ereturn local predict "`ivreg2cmd'_p"
      if "`e(model)'"=="gmm2s" & "`wmatrix'"=="" {
      local title2 "2-Step GMM estimation"
      }
      else if "`e(model)'"=="gmm2s" & "`wmatrix'"~="" {
      local title2 "2-Step GMM estimation with user-supplied first-step weighting matrix"
      }
      else if "`e(model)'"=="gmmw" {
      local title2 "GMM estimation with user-supplied weighting matrix"
      }
      else if "`e(model)'"=="cue" & "`b0'"=="" {
      local title2 "CUE estimation"
      }
      else if "`e(model)'"=="cue" & "`b0'"~="" {
      local title2 "CUE evaluated at user-supplied parameter vector"
      }
      else if "`e(model)'"=="ols" {
      local title2 "OLS estimation"
      }
      else if "`e(model)'"=="iv" {
      local title2 "IV (2SLS) estimation"
      }
      else if "`e(model)'"=="liml" {
      local title2 "LIML estimation"
      }
      else if "`e(model)'"=="kclass" {
      local title2 "k-class estimation"
      }
      else {
      local title2 "unknown estimation"
      }
      if "`e(vcetype)'" == "Robust" {
      local hacsubtitle1 "heteroskedasticity"
      }
      if "`e(kernel)'"!="" & "`e(clustvar)'"=="" {
      local hacsubtitle3 "autocorrelation"
      }
      if "`kiefer'"!="" {
      local hacsubtitle3 "within-cluster autocorrelation (Kiefer)"
      }
      if "`e(clustvar)'"!="" {
      if "`e(clustvar2)'"=="" {
      local hacsubtitle3 "clustering on `e(clustvar)'"
      }
      else {
      local hacsubtitle3 "clustering on `e(clustvar1)' and `e(clustvar2)'"
      }
      if "`e(kernel)'" != "" {
      local hacsubtitle4 "and kernel-robust to common correlated disturbances (Driscoll-Kraay)"
      }
      }
      if "`hacsubtitle1'"~="" & "`hacsubtitle3'" ~= "" {
      local hacsubtitle2 " and "
      }
      if "`title'"=="" {
      ereturn local title "`title1'`title2'"
      }
      else {
      ereturn local title "`title'"
      }
      if "`subtitle'"~="" {
      ereturn local subtitle "`subtitle'"
      }
      local hacsubtitle "`hacsubtitle1'`hacsubtitle2'`hacsubtitle3'"
      if "`b0'"~="" {
      ereturn local hacsubtitleB "Estimates based on supplied parameter vector"
      }
      else if "`hacsubtitle'"~="" & "`gmm2s'`cue'"~="" {
      ereturn local hacsubtitleB "Estimates efficient for arbitrary `hacsubtitle'"
      }
      else if "`wmatrix'"~="" {
      ereturn local hacsubtitleB "Efficiency of estimates dependent on weighting matrix"
      }
      else {
      ereturn local hacsubtitleB "Estimates efficient for homoskedasticity only"
      }
      if "`hacsubtitle'"~="" {
      ereturn local hacsubtitleV "Statistics robust to `hacsubtitle'"
      }
      else {
      ereturn local hacsubtitleV "Statistics consistent for homoskedasticity only"
      }
      if "`hacsubtitle4'"~="" {
      ereturn local hacsubtitleV2 "`hacsubtitle4'"
      }
      if "`sw'"~="" {
      ereturn local hacsubtitleV "Stock-Watson heteroskedastic-robust statistics (BETA VERSION)"
      }
      if ("`absorb'" != "") {
      mata: HDFE.post_footnote()
      assert e(N_hdfe) != .
      mata: st_local("residuals_name", HDFE.residuals)
      if ("`residuals_name'" != "") {
      mata: HDFE.save_variable(HDFE.residuals, hdfe_residuals, "Residuals")
      mata: st_global("e(resid)", HDFE.residuals)
      reghdfe_store_alphas
      }
      }
      }
    ---------------------------------------------------------------------------------------------------------- end ivreghdfe.ivreg211 ---
    cap mata: mata drop HDFE
    cap mata: mata drop hdfe_residuals
    ereturn local cmd "ivreghdfe"
    ereturn local ivreg2cmd "ivreghdfe"
    ereturn local version `lversion'
    ereturn local predict ivreg2_p
    if (e(N_hdfe)!= .) ereturn local predict reghdfe_p
    }
  --------------------------------------------------------------------------------------------------------------------- end ivreghdfe ---
r(198);

end of do-file

r(198);

. do /var/folders/8t/vrwvxbq9129fh7d79bzmwnn00000gq/Tselectedlines_piupiu.do

. set trace off

. 
end of do-file

. do /var/folders/8t/vrwvxbq9129fh7d79bzmwnn00000gq/Tselectedlines_piupiu.do

. ivreghdfe headroom mpg (weight = length), absorb(rep78)
option requirements not allowed
r(198);

end of do-file

r(198);

